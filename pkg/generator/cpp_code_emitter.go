package generator

import (
	"bufio"
	"fmt"
	"os"
	"strconv"
	"strings"
)

type CppCodeEmitter struct {
	OutputFile *os.File
	Writer     *bufio.Writer

	TabIndex      int
	InPublicBlock bool
}

type CppVariable struct {
	Name string
	Type string
}

const (
	// TODO: Make configurable for x64 calling convention
	DEFAULT_FUNCTION_CALLING_CONVENTION = "__stdcall"
	DEFAULT_METHOD_CALLING_CONVENTION   = "__thiscall"
)

func NewCppCodeEmitter(path string) *CppCodeEmitter {
	e := new(CppCodeEmitter)
	file, err := os.Create(path)
	if err != nil {
		panic(err)
	}

	e.OutputFile = file
	e.Writer = bufio.NewWriter(e.OutputFile)
	e.TabIndex = 0
	e.InPublicBlock = false

	return e
}

func (s *CppCodeEmitter) Close() {
	s.Writer.Flush()
	s.OutputFile.Close()
}

func (s *CppCodeEmitter) EmitHeader() {
	s.Writer.WriteString("// DO NOT EDIT. THIS FILE IS GENERATED BY THE RELANG COMPILER\n")
}

func (s *CppCodeEmitter) EmitLineComment(comment string) {
	s.EmitIndentation()
	s.Writer.WriteString("// " + comment + "\n")
}

func (s *CppCodeEmitter) EmitSeparator() {
	s.Writer.WriteString(";")
}

func (s *CppCodeEmitter) EmitIndentation() {
	s.Writer.WriteString(strings.Repeat("    ", s.TabIndex))
}

func (s *CppCodeEmitter) EmitLine(line string, separator bool) {
	s.EmitIndentation()

	if separator {
		s.Writer.WriteString(line + ";\n")
	} else {
		s.Writer.WriteString(line + "\n")
	}
}

func (s *CppCodeEmitter) EmitPublicBlock() {
	if !s.InPublicBlock {
		s.TabIndex = s.TabIndex - 1 // temporally step back tab index
		s.EmitLine("public:", false)
		s.TabIndex = s.TabIndex + 1
		s.InPublicBlock = true
	}
}

func (s *CppCodeEmitter) EmitPrivateBlock() {
	if s.InPublicBlock {
		s.TabIndex = s.TabIndex - 1 // temporally step back tab index
		s.EmitLine("private:", false)
		s.TabIndex = s.TabIndex + 1 // temporally step back tab index
		s.InPublicBlock = false
	}
}

func (s *CppCodeEmitter) EmitIncludeStatement(includePath string) {
	s.EmitLine("#include \""+includePath+"\"", false)
}

func (s *CppCodeEmitter) EmitClassDeclarationStart(className string, baseClasses []string) {
	if len(baseClasses) > 0 {
		baseClassEnumeration := strings.Join(baseClasses, ", public ")
		s.EmitLine(fmt.Sprintf("class %s : public %s\n{", className, baseClassEnumeration), false)
	} else {
		s.EmitLine(fmt.Sprintf("class %s\n{", className), false)
	}
	s.TabIndex = s.TabIndex + 1
}

func (s *CppCodeEmitter) EmitClassDeclarationEnd() {
	s.TabIndex = s.TabIndex - 1
	s.EmitLine("}", true)
}

func (s *CppCodeEmitter) EmitFunctionDeclaration(functionName string, returnType string, params []CppVariable, memoryAddress string, callingConv string, inClass bool) {
	if inClass {
		s.EmitPublicBlock()

		if len(callingConv) == 0 {
			callingConv = DEFAULT_METHOD_CALLING_CONVENTION
		}
	} else if len(callingConv) == 0 {
		callingConv = DEFAULT_FUNCTION_CALLING_CONVENTION
	}

	s.EmitLine(fmt.Sprintf("inline %s %s(%s)", returnType, functionName, CppFunctionParametersToString(params)), false)
	s.EmitLine("{", false)
	s.TabIndex = s.TabIndex + 1

	if inClass {
		params = append([]CppVariable{CppVariable{Name: "this", Type: "decltype(this)"}}, params...)
	}

	s.EmitLine(fmt.Sprintf("using Func_t = %s(%s *)(%s)", returnType, callingConv, CppFunctionParameterTypesToString(params)), true)
	s.EmitLine(fmt.Sprintf("auto f = reinterpret_cast<Func_t>(%s)", memoryAddress), true)
	s.EmitLine(fmt.Sprintf("return f(%s)", CppFunctionParameterNamesToString(params)), true)

	s.TabIndex = s.TabIndex - 1
	s.EmitLine("}\n", false)
}

func (s *CppCodeEmitter) EmitVariableDeclaration(variable CppVariable, memoryOffset uint, inClass bool) {
	if inClass {
		s.EmitPublicBlock()
	}

	s.EmitLineComment("offset " + strconv.FormatUint(uint64(memoryOffset), 10))
	s.EmitLine(variable.Type+" "+variable.Name, true)

	// TODO: Insert pads for correct offsetting
}
